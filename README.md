## Content
* [Container's operations complexity](https://github.com/byteihq/cheat-sheets#containers-operations-complexity)
* [Vector](https://github.com/byteihq/cheat-sheets#vector)
  + [Implementation](https://github.com/byteihq/cheat-sheets#implementation)
* [Deque](https://github.com/byteihq/cheat-sheets#deque)
  + [Idea](https://github.com/byteihq/cheat-sheets#idea)
* [Stack](https://github.com/byteihq/cheat-sheets#stack)
  + [Idea](https://github.com/byteihq/cheat-sheets#idea-1)
  + [Notes](https://github.com/byteihq/cheat-sheets#notes)
* [Queue](https://github.com/byteihq/cheat-sheets#queue)
* [Priority Queue](https://github.com/byteihq/cheat-sheets#priority-queue)
* [Forward_List](https://github.com/byteihq/cheat-sheets#forward_list)
    + [Idea](https://github.com/byteihq/cheat-sheets#idea-1)
    + [Notes](https://github.com/byteihq/cheat-sheets#notes)
* [List](https://github.com/byteihq/cheat-sheets#list)
    + [Idea](https://github.com/byteihq/cheat-sheets#idea-2)
    + [Notes](https://github.com/byteihq/cheat-sheets#notes-1)
* [HashTable](https://github.com/byteihq/cheat-sheets#hashtable)
  + [Idea](https://github.com/byteihq/cheat-sheets#idea-4) 
* [GCC Compile Flags](https://github.com/byteihq/cheat-sheets#gcc-compile-flags)
* [Pointers](https://github.com/byteihq/cheat-sheets#pointers)
    + [Pointers with const modidfcator](https://github.com/byteihq/cheat-sheets#pointers-with-const-modidfcator)
    + [Pointers arithmetic](https://github.com/byteihq/cheat-sheets#pointers-arithmetic)
    + [Smart Pointers](https://github.com/byteihq/cheat-sheets#smart-pointers)
* [Diamond inheritance problem](https://github.com/byteihq/cheat-sheets#diamond-inheritance-problem)
    + [Case](https://github.com/byteihq/cheat-sheets#case)
    + [Possible solution](https://github.com/byteihq/cheat-sheets#possible-solution)
    + [Notes](https://github.com/byteihq/cheat-sheets#notes-3)
 * [Polymorphism](https://github.com/byteihq/cheat-sheets/blob/main/README.md#polymorphism)
    + [Static](https://github.com/byteihq/cheat-sheets/blob/main/README.md#static)
    + [Dynamic](https://github.com/byteihq/cheat-sheets/blob/main/README.md#dynamic)
      - [Case 1](https://github.com/byteihq/cheat-sheets/blob/main/README.md#case-1)
      - [Case 2](https://github.com/byteihq/cheat-sheets/blob/main/README.md#case-2)
      - [Case 3](https://github.com/byteihq/cheat-sheets/blob/main/README.md#case-3)
      - [Case 4](https://github.com/byteihq/cheat-sheets/blob/main/README.md#case-4)
      - [Case 5](https://github.com/byteihq/cheat-sheets/blob/main/README.md#case-5)
      - [Case 6](https://github.com/byteihq/cheat-sheets/blob/main/README.md#case-6)
      - [Shoot yourself in the leg](https://github.com/byteihq/cheat-sheets/blob/main/README.md#shoot-yourself-in-the-leg)
    + [Key word override](https://github.com/byteihq/cheat-sheets/blob/main/README.md#key-word-override)
      - [Case 1](https://github.com/byteihq/cheat-sheets/blob/main/README.md#case-1-1)
      - [Case 2](https://github.com/byteihq/cheat-sheets/blob/main/README.md#case-2-1)
    + [Key word final](https://github.com/byteihq/cheat-sheets/blob/main/README.md#key-word-final)
      - [Case 1](https://github.com/byteihq/cheat-sheets/blob/main/README.md#case-1-2)
      - [Case 2](https://github.com/byteihq/cheat-sheets/blob/main/README.md#case-2-2)
    + [Vtables](https://github.com/byteihq/cheat-sheets/blob/main/README.md#vtables)
      - [Example](https://github.com/byteihq/cheat-sheets/blob/main/README.md#example) 
* [Design Patterns](https://github.com/byteihq/cheat-sheets/blob/main/README.md#design-patterns)
  + [Factory Method](https://github.com/byteihq/cheat-sheets/blob/main/README.md#factory-method)
    - [Example](https://github.com/byteihq/cheat-sheets/blob/main/README.md#example)
    - [Notes](https://github.com/byteihq/cheat-sheets/blob/main/README.md#notes-4)
  + [Singleton](https://github.com/byteihq/cheat-sheets/blob/main/README.md#singleton)
    - [Example](https://github.com/byteihq/cheat-sheets/blob/main/README.md#example-by-scott-meyers)
    - [Notes](https://github.com/byteihq/cheat-sheets/blob/main/README.md#notes-5)
  + [Observer](https://github.com/byteihq/cheat-sheets/blob/main/README.md#observer)
    - [Example](https://github.com/byteihq/cheat-sheets/blob/main/README.md#example-1) 
    - [Notes](https://github.com/byteihq/cheat-sheets/blob/main/README.md#notes-6)
  + [Adapter](https://github.com/byteihq/cheat-sheets/blob/main/README.md#adapter)
    - [Example](https://github.com/byteihq/cheat-sheets/blob/main/README.md#example-2)
    - [Notes](https://github.com/byteihq/cheat-sheets/blob/main/README.md#notes-7)
* [ThreadPool](https://github.com/byteihq/cheat-sheets#threadpool)
  + [Implementation](https://github.com/byteihq/cheat-sheets#implementation-1)
  + [Notes](https://github.com/byteihq/cheat-sheets#notes-8)
* [Async Programming](https://github.com/byteihq/cheat-sheets/blob/main/README.md#async-programming)
  + [Example](https://github.com/byteihq/cheat-sheets/blob/main/README.md#example-4)
  + [Coroutines](https://github.com/byteihq/cheat-sheets/blob/main/README.md#coroutines)
    - [Python](https://github.com/byteihq/cheat-sheets/blob/main/README.md#python-example)
    - [C++20](https://github.com/byteihq/cheat-sheets/blob/main/README.md#c20-coroutines)
    - [Stackful vs Stackless](https://github.com/byteihq/cheat-sheets/blob/main/README.md#stackful-vs-stackless)
  + [Atomic Operations](https://github.com/byteihq/cheat-sheets/blob/main/README.md#atomic-operations)
    - [Example 1](https://github.com/byteihq/cheat-sheets/blob/main/README.md#example-1-1)
    - [Example 2](https://github.com/byteihq/cheat-sheets/blob/main/README.md#example-2-1)
    - [Notes](https://github.com/byteihq/cheat-sheets/blob/main/README.md#notes-9)
  + [Lock-free Programming](https://github.com/byteihq/cheat-sheets/blob/main/README.md#lock-free-and-wait-free-programming)
    - [Lock-free Stack](https://github.com/byteihq/cheat-sheets/blob/main/README.md#lock-free-stack)
  + [ABA Problem](https://github.com/byteihq/cheat-sheets#aba-problem)
* [Exetrnal and Internal Linkage](https://github.com/byteihq/cheat-sheets/blob/main/README.md#external-and-internal-linkage)
  + [Declaration vs Definition](https://github.com/byteihq/cheat-sheets/blob/main/README.md#declaration-vs-definition)
    - [Example](https://github.com/byteihq/cheat-sheets/blob/main/README.md#example-5)
  + [Forward Declaration](https://github.com/byteihq/cheat-sheets/blob/main/README.md#forward-declaration)
    - [Example](https://github.com/byteihq/cheat-sheets/blob/main/README.md#example-6)
  + [External Linkage](https://github.com/byteihq/cheat-sheets/blob/main/README.md#external-linkage)
    - [Example 1](https://github.com/byteihq/cheat-sheets/blob/main/README.md#example-1-2)
    - [Example 2](https://github.com/byteihq/cheat-sheets/blob/main/README.md#example-2-2)
  + [Internal Linkage](https://github.com/byteihq/cheat-sheets/blob/main/README.md#internal-linkage)  
* [Hunter](https://github.com/byteihq/cheat-sheets#hunter)
    + [Install](https://github.com/byteihq/cheat-sheets#install)
* [Sources](https://github.com/byteihq/cheat-sheets#sources)

## Container's operations complexity

| Container | indexing [] | push_back | insert | erase | find |
|-----------|-------------|-----------|--------|-------|------|
|  [vector](https://en.cppreference.com/w/cpp/container/vector)   | O(1)        | O(1) amort| O(N)   | O(N)  |  none|
| [deque](https://en.cppreference.com/w/cpp/container/deque) | O(1) | O(1) amort | O(N) | O(N) | none |
|[list](https://en.cppreference.com/w/cpp/container/list) / [forward_list](https://en.cppreference.com/w/cpp/container/forward_list)| none | O(1) | O(1) | O(1) | none |
|[set](https://en.cppreference.com/w/cpp/container/set) / [map](https://en.cppreference.com/w/cpp/container/map)| O(logN) |none|O(logN)|O(logN)|O(logN)|
|[unordered_set](https://en.cppreference.com/w/cpp/container/unordered_set) / [unordered_map](https://en.cppreference.com/w/cpp/container/unordered_map)| Q(1) mean | none | O(1) mean| O(1) mean| O(1) mean|

## Vector
### [Implementation](https://github.com/byteihq/Vector)

## Deque
### [Idea](https://github.com/byteihq/Deque)

## Stack
### Idea
```cpp
template<typename T>
class Stack {
private:
    struct Node {
        T value_;
        Node* next_;
    };
    Node* head_;
};
```
```cpp
template<typename T>
class Stack {
private:
    T* data;
    size_t head;
};
```
### Notes
_Stack is a LIFO data structure. It has methods push (by default it calls deque.push_back()) and pop (by default it calls deque.pop_back())_

## Queue
_Similar to stack, but it's a FIFO data structure. Also has methods push (by default it calls deque.push_back()) and pop (by default it calls deque.pop_front())_

## Priority Queue
_Similar to queue but it has logarithmic insertion and extraction, because of it stores objects in an orderly fashion, it allows to get the largest object for the constant time_

## Forward_List
### Idea
```cpp
template<typename T>
class ForwardList {
private:
    struct Node {
        T value_;
        Node* next_;
    };
    Node* head_;
};
```
### Notes
[How to reverse a forward list?](https://www.youtube.com/watch?v=PQIHq0vfADI&ab_channel=CodeWhoop)

## List
### Idea
```cpp
template<typename T>
class List {
private:
    struct Node {
        T value_;
        Node* next_;
        Node* prev_;
    };
    Node* head_;
};
```
### Notes
[Method splice has a linear complexity when we want to splice a part of another list, because we need to recalculate a new size](https://en.cppreference.com/w/cpp/container/list/splice)

## HashTable
### [Idea](https://github.com/byteihq/HashTable/blob/main/README.md)

## GCC Compile Flags
1. **-Wpedantic (-pedantic)** - checks that the code complies with the ISO C ++ standard, reports on the use of prohibited extensions, on the presence of extra semicolons, lack of line breaks at the end of the file, and other useful things
2. **-Werror** - warning = error
3. **-Wall** - turn on basic warnings
4. **-Wextra** - turn on extra warnings
5. **-Wshadow** - warn whenever a local variable or type declaration shadows another variable
6. **-Wnon-virtual-dtor** - tells the compiler to issue a warning when a class appears to be polymorphic, yet it declares a non-virtual one

[More information](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html)

## Pointers
### Pointers with const modidfcator
1. Just a pointer
```cpp
int a = 4;
int b = 1;
int *p = &a;
*p = 3;
p = &b;
*p = 2;
//there is no error
```
2. Pointer to const object
```cpp
int a = 4;
int b = 1;
const int *p = &a; //it's equal to int const* p = &a;
//*p = 2; - this operation is unavailable because p is a pointer to const int
p = &b; // works fine
```
3. Const pointer to non const object
```cpp
int a = 4;
int b = 1;
int *const p = &a;
*p = 2; //works fine
//++p; - this operation is unavailable because p is a const pointer to int
```
4. Const pointer to const object
```cpp
int a = 4;
int b = 1;
const int *const p = &a;
/*
++p;
p = &b;
these operations are unavailable because p is a const pointer to const int
*/
```
### Pointers arithmetic
```cpp
int8_t i8;
int64_t i64;
int8_t *p8 = &i8;
int64_t *p64 = &i64;

p8 += 10; //shift by 10 * sizeof(int8_t) bytes = 10 bytes
p64 += 10; //shift by 10 * sizeof(int64_t) bytes = 80 bytes;
```
### Smart Pointers
1. [Scooped Ptr](https://cs.brown.edu/~jwicks/boost/libs/smart_ptr/scoped_ptr.htm) - **uncopyable, unmovable**
2. [Weak Ptr](https://en.cppreference.com/w/cpp/memory/weak_ptr) - **std::weak_ptr models temporary ownership: when an object needs to be accessed only if it exists, and it may be deleted at any time by someone else, std::weak_ptr is used to track the object, and it is converted to std::shared_ptr to assume temporary ownership. It has _expired_ method to check whether the referenced object was already deleted**
3. [Unique Ptr](https://en.cppreference.com/w/cpp/memory/unique_ptr) - **uncopyable, movable**
4. [Shared Ptr](https://en.cppreference.com/w/cpp/memory/shared_ptr) - **copyable, movable (also has atomic reference counter)**

## Diamond inheritance problem
### Case
```cpp
struct A {
    int a;
};

struct B : public A {
    int b;
};

struct C : public A {
    int c;
};

struct D : public B, public C {
    int d;
};

int main() {
    D d;
    d.a;
}
```
_Result - CE_

_Location of objects in memory - ( a )( b )( a )( c )( d )_
### Possible solution
```cpp
struct A {
    int a;
};

struct B : public virtual A {
    int b;
};

struct C : public virtual A {
    int c;
};

struct D : public B, public C {
    int d;
};

int main() {
    D d;
    d.a;
}
```
_Location of objects in memory - ( b_ptr )( b )( c_ptr )( c )( d )( a )_

### Notes
1. If we'll inherit virtually only one time, it won't solve this problem
```cpp
struct A {
    int a;
};

struct B : public A {
    int b;
};

struct C : public virtual A {
    int c;
};

struct D : public B, public C {
    int d;
};

int main() {
    D d;
    d.a;
}
```
_Location of objects in memory - ( a )( b )( c_ptr )( c )( d )( a )_

2. Virtual inherit in the also won't solve the problem.
```cpp
struct A {
    int a;
};

struct B : public A {
    int b;
};

struct C : public A {
    int c;
};

struct D : public virtual B, public virtual C {
    int d;
};

int main() {
    D d;
    d.a;
}
```
_Location of objects in memory - ( d_ptr )->( b_ptr && c_ptr )( d )( a )( b )( a )( c )_

3. Kill this guy
```cpp
struct A {
    int a;
};

struct B : public A {
    int b;
};

struct D : public B, public A {
    int d;
};

int main() {
    D d;
    d.a;
}
```
_Location of objects in memory - ( a )( b )( a )( d )_
## Polymorphism
### Static
```cpp
struct A {
    void f() { std::cout << "A"; }
};

struct B : public A {
    void f() { std::cout << "B"; }
};

int main() {
    A a;
    a.f();
    B b;
    b.f();
    b.A::f();
}
```
_Output - ABA_

_Which method should be called is only decided at compile time_
### Dynamic
_Which method should be called is decided at runtime_
#### Case 1
```cpp
struct A {
    void f() { std::cout << "A"; }
};

struct B : public A {
    void f() { std::cout << "B"; }
};

int main() {
    B b;
    A& ar = b;
    ar.f();
}
```
_Output - A_
#### Case 2
```cpp
struct A {
    virtual void f() { std::cout << "A"; }
};

struct B : public A {
    void f() { std::cout << "B"; }
};

int main() {
    B b;
    A& ar = b;
    ar.f();
}
```
_Output - B_

_The same output will be if we'll write **virtual** before f() in B_
#### Case 3
```cpp
struct A {
    virtual void f() { std::cout << "A"; }
};

struct B : public A {
    void f() const { std::cout << "B"; }
};

int main() {
    B b;
    A& ar = b;
    ar.f();
}
```
_Output - A_
#### Case 4
```cpp
struct A {
    virtual void f() { std::cout << "A"; }
};

struct B : public A {
    void f() { std::cout << "B"; }
};

int main() {
    B b;
    const A& ar = b;
    ar.f();
}
```
_Output - CE_
#### Case 5
```cpp
struct A {
    virtual void f() const { std::cout << "A"; }
};

struct B : public A {
    void f() { std::cout << "B"; }
};

int main() {
    B b;
    const A& ar = b;
    ar.f();
}
```
_Output - A_
#### Case 6
```cpp
struct A {
    virtual void f() const { std::cout << "A"; }
};

struct B : public A {
    void f() const { std::cout << "B"; }
};

int main() {
    B b;
    const A& ar = b;
    ar.f();
}
```
_Output - B_
#### Shoot yourself in the leg
```cpp
class A {
public:
    virtual void f() {
        std::cout << "A";
    }
};

class B : public A {
private:
    void f() override {
        std::cout << "B";
    }
};

int main() {
    A* a = new B();
    a->f();
    delete a;
    return 0;
}
```
_Output - B_

![](https://sun9-61.userapi.com/impg/AQ9Z2xGxRNt8PNujNTxYU_kFFmfzwVWzF3NxLg/M7gDMXMygqc.jpg?size=510x587&quality=96&sign=9810b2a2294fa9df41d4948adcc86f89&type=album)
### Key word _override_
_Indicates that the function has been overridden, required by code-style_
#### Case 1
```cpp
struct A {
    virtual void f() const { std::cout << "A"; }
};

struct B : public A {
    void f() const override { std::cout << "B"; }
};

int main() {
    B b;
    const A& ar = b;
    ar.f();
}
```
_Output - B_
#### Case 2
```cpp
struct A {
    virtual void f() const { std::cout << "A"; }
};

struct B : public A {
    void f() override { std::cout << "B"; }
};

int main() {
    B b;
    const A& ar = b;
    ar.f();
}
```
_Output - CE_
### Key word _final_
_Disallows further overrides_
#### Case 1
```cpp
struct A {
    virtual void f() const { std::cout << "A"; }
};

struct B : public A {
    void f() const override final { std::cout << "B"; }
};

int main() {
    B b;
    const A& ar = b;
    ar.f();
}
```
_Output - B_
#### Case 2
```cpp
struct A {
    virtual void f() const final { std::cout << "A"; }
};

struct B : public A {
    void f() const override { std::cout << "B"; }
};

int main() {
    B b;
    const A& ar = b;
    ar.f();
}
```
_Output - CE_
### Vtables
#### Example
```cpp
struct A1 {};

struct A2 {
    int a;
};

struct A3 {
    int a;
    void f() {}
};

struct A4 {
    int a;
    virtual void f() {}
};

int main() {
    std::cout << sizeof(A1) << ' ' << sizeof(A2) << ' ' << sizeof(A3) << ' ' << sizeof(A4);
    return 0;
}
```
_Output - 1 4 4 16_

**A4 - ( v_ptr ) -> ( typeinfo_ptr [RTTI](https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F_%D1%82%D0%B8%D0%BF%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85) )( &f() ) ( a ). 8 + 4 = 12 = 16 (due to alignment)**
## Design Patterns
### Factory Method
#### Example
```cpp
class Product {
private:
    size_t cost_;
    size_t weight_;
public:
    virtual ~Product() {}

    virtual Product* create() = 0;

    size_t cost() const { return cost_; }
    
    size_t weight() const { return weight_; }
};

class Bread : public Product {
public:
    Product* create() override {
        return new Bread;
    }
};

class Milk : public Product {
public:
    Product* create() override {
        return new Milk;
    }
};
```
#### Notes
A factory method defines a method that should be used instead of calling a **new** one to create product objects. Subclasses can override this method to change the type of products they create.
### Singleton
#### Example (by Scott Meyers)
```cpp
class Singleton {
private:
  Singleton() {}
  Singleton(const Singleton&) = delete;
  Singleton& operator=(Singleton&) = delete;
public:
  static Singleton& getInstance() {
    static Singleton instance;
    return instance;
  }
};
```
#### Notes
It's very simple to implement a single clumsy Singleton - you just need to hide the constructor and provide a static creating method. **The same class behaves incorrectly in a multithreaded environment**. Multiple threads can simultaneously call the Singleton's getter method and create multiple instances of the object at once.
### Observer
#### Example
```cpp
class Handler {
public:
    class HandlerObserver {
    public:
        virtual void Update() const = 0;
    };

    void AddObserver(const HandlerObserver &observer);

    void DeleteObserver(const HandlerObserver &observer);

    void DoSmth();

private:
    void NotifyAll();

    std::vector<const HandlerObserver *> observers_;
};

void Handler::AddObserver(const HandlerObserver &observer) {
    observers_.push_back(&observer);
}

void Handler::DeleteObserver(const HandlerObserver &observer) {
    auto it = std::remove(observers_.begin(), observers_.end(), &observer);
    observers_.erase(it, observers_.end());
}

void Handler::DoSmth() {
    // some code
    NotifyAll();
    // other code
}

void Handler::NotifyAll() {
    for (const auto &observer: observers_) {
        observer->Update();
    }
}

class Observer : public Handler::HandlerObserver {
public:
    void Update() const override;
};

void Observer::Update() const {
    // notification
}
```
#### Notes
Observer is a behavioral design pattern that creates a subscription mechanism that allows one object to watch and respond to events occurring in other objects.
### Adapter
#### Example
```cpp
class English {
public:
    virtual std::string sayHello() const {
        return "Hello";
    }
};

class Spanish {
public:
    std::string sayHello() const {
        return "Hola";
    }
};

class Adaptor : public English {
private:
    Spanish *spanish_;

    std::string translateToEnglish(const std::string& msg) {
        // translation
        return translatedMsg;
    }
public:
    Adaptor(Spanish *spanish) : spanish_(spanish) {}

    std::string sayHello() const override {
        auto spanishHello = spanish_->sayHello();
        return translateToEnglish(spanishHello);
    }
};

void EnglishSpeakingPerson(English* eng) {
    // some code
}

int main() {
    Spanish spanish;
    Adaptor adaptor(&spanish);
    EnglishSpeakingPerson(&adaptor);
    return 0;
}
```
#### Notes
The adapter acts as a layer between two objects, converting the calls of one into calls that are understandable to the other.
## ThreadPool
![](https://bmstu-iu8-cpp.github.io/cpp-upper-intermediate/lec_07/res/multitask2.jpg)
### [Implementation](https://github.com/progschj/ThreadPool)
### Notes
A thread pool is a set of a fixed number of threads that are created when the application starts. Threads then sit and wait for requests coming to them, usually through a semaphore-driven queue. When a request is made and at least one thread is waiting, the thread wakes up, services the request, and returns to waiting on the semaphore. If no threads are available, requests are queued until one of them is available. Thread pools are generally a more efficient way to manage resources than just starting a new thread for each request. However, some architectures allow new threads to be created and added to the pool as the application runs, depending on the load on the request.
## Async Programming
Asynchronous programming is a form of parallel programming that allows a unit of work to run separately from the primary application thread. When the work is complete, it notifies the main thread (as well as whether the work was completed or failed).
### Example
```cpp
HandleConnection::pointer connection = HandleConnection::create(*ioService_);
acceptor_.async_accept(*connection->getSocket(),
                       boost::bind(&Server::handleAccept, this, connection,
                                   boost::asio::placeholders::error));
```
### Coroutines
Essentially, coroutines are functions that have multiple entry and exit points.
#### Python Example
```python
def async_factorial():
    result = 1
    while True:
        yield result
        result *= i

fac = async_factorial()

for i in range(42):
    print(next(fac))
```
The program will print the entire sequence of factorial numbers numbered from 0 to 41.
The `async_factorial()` function will return a generator object that can be passed to the `next()` function, and it will continue executing the coroutine until the next yield statement while maintaining the state of all local variables of the function. The `next()` function returns what is passed by the yield statement inside the coroutine. Thus, the `async_factorial()` function in theory has multiple entry and exit points.
#### C++20 Coroutines
1. `co_await` A unary operator that allows, in general, to suspend the execution of a coroutine and transfer control to the caller until the calculations represented by the operand are completed;
2. `co_yield` A unary operator, a special case of the co_await operator, which allows you to suspend the execution of a coroutine and transfer control and the value of the operand to the caller;
3. `co_return` The statement terminates the coroutine by returning a value; after the call, the coroutine will no longer be able to resume its execution.
##### Articles
1. https://habr.com/ru/post/519464/

More code

2. https://blog.feabhas.com/2021/09/c20-coroutines/
3. https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html
##### Implementations
1. https://github.com/lewissbaker/cppcoro
2. https://github.com/David-Haim/concurrencpp/

Waiting for high-level coroutines in c++23...
#### Stackful vs Stackless
Depending on the use of the stack, coroutines are divided into stackful, where each coroutine has its own stack, and stackless, where all local variables of the function are stored in a special object.

Since we can put the `yield statement` anywhere in coroutines, we need to save the entire function context somewhere, which includes the frame on the stack (local variables) and other meta information. This can be done, for example, by completely replacing the stack, as is done in stackful coroutines.

In the figure below, calling async creates a new stack frame and switches thread execution to it. This is practically a new thread, only it will be executed asynchronously with the main one.

`yield`, in turn, returns back the previous stack frame for execution, keeping a reference to the end of the current one on the previous stack.

![](https://tproger.ru/s3/uploads/2018/12/image1-3.png)

### Atomic Operations
#### Example 1
```cpp
int value = 0;

void f() {
    ++value;
}

int main() {
    std::vector<std::thread> threads;
    for (size_t i = 0; i < 20; ++i) {
        threads.emplace_back(f);
    }
    for (auto&& thread : threads) {
        thread.join();
    }
    std::cout << value;
    return 0;
}
```
_Output - who knows..._
#### Example 2
```cpp
std::atomic<int> value = 0;

void f() {
    ++value;
}

int main() {
    std::vector<std::thread> threads;
    for (size_t i = 0; i < 20; ++i) {
        threads.emplace_back(f);
    }
    for (auto&& thread : threads) {
        thread.join();
    }
    std::cout << value;
    return 0;
}
```
_Output - 20_
#### Notes
Atomicity means the indivisibility of an operation. This means that no thread can see the intermediate state of the operation, it is either in progress or not. If you are using [std::atomic<>](https://en.cppreference.com/w/cpp/atomic/atomic) from a non-trivial template, then most likely this will lead to using standard `std::mutex`
Most common methods:
1. `load()` atomically obtains the value of the atomic object
2. `store()` atomically replaces the value of the atomic object with a non-atomic argument
3. `exchange() = store() + load()` atomically replaces the value of the atomic object and obtains the value held previously
4. `compare_exchange_weak()` atomically compares the value of the atomic object with non-atomic argument and performs atomic exchange if equal or atomic load if not

The difference between `compare_exchange_weak` and `compare_exchange_strong` is that `compare_exchange_weak` on some platforms may fail falsely (i.e. return false and fail to exchange even if the values are equal). `compare_exchange_strong` calls `compare_exchange_weak` in a loop. When `compare_exchange_strong` is called in a loop it makes sense to use `compare_exchange_weak` to avoid nested loops. A very important point is that all operations on atomic types in C ++ 0x are sequentially consistent by default, i.e. all operations with atomic types are performed and observed by other processors in the order in which they were written.
### Lock-free (and wait-free) programming
**Lock-free** - lock-free is the procedure for which the progress of at least one thread performing this procedure is guaranteed. Other threads can wait, but at least one thread must progress.

**Wait-free** - an operation is called wait-free if it completes in a certain number of steps that do not depend on the state and actions of other threads.

#### Lock-free Stack
```cpp
template<typename T>
class Stack {
private:
    struct Node {
        std::shared_ptr<T> value_;
        Node *next_;

        explicit Node(const T &value, Node *next = nullptr) : value_(std::make_shared<T>(value)), next_(next) {}
    };

    std::atomic<Node *> head_;
    std::atomic<Node *> need_delete_;
    std::atomic<size_t> threads_in_pop_;

    void append_list_to_be_deleted(Node *begin, Node *end) {
        end->next_ =  need_delete_;
        while (!need_delete_.compare_exchange_weak(end->next_, begin));
    }

    void append_list_to_be_deleted(Node *begin) {
        auto end = begin;
        while (end->next_) {
            end = end->next_;
        }
        append_list_to_be_deleted(begin, end);
    }

    void delete_nodes(Node *node) {
        while (node) {
            auto next = node->next_;
            delete node;
            node = next;
        }
    }

    void try_delete(Node *node) {
        if (threads_in_pop_ == 1) {
            auto nodes_to_be_deleted = need_delete_.exchange(nullptr);
            if (--threads_in_pop_ == 0) {
                delete_nodes(nodes_to_be_deleted);
            } else if (nodes_to_be_deleted) {
                append_list_to_be_deleted(nodes_to_be_deleted);
            }
            delete node;
        } else {
            append_list_to_be_deleted(node);
            --threads_in_pop_;
        }
    }


public:
    Stack() : head_(nullptr), need_delete_(nullptr), threads_in_pop_(0) {}

    void push(const T &value) {
        Node* new_node = new Node(value, head_.load());
        while (!head_.compare_exchange_weak(new_node->next_, new_node));
        /*
         * if (head_ == new_node->next_) {
         *  head_ = new_node;
         *  return true;
         * }
         * new_node->next_ = head_;
         * return false;
        */
    }

    std::shared_ptr<T> pop() {
        ++threads_in_pop_;
        auto old_head = head_.load();
        while (old_head && !head_.compare_exchange_weak(old_head, old_head->next_));
        /*
         * if (head_ == old_head) {
         *  head_ = old_head->next_;
         *  return true;
         * }
         * old_head = head_;
         * return false;
        */
        std::shared_ptr<T> res;
        if (old_head) {
           res.swap(old_head->value_);
        }

        try_delete(old_head);

        return res;
    }

    ~Stack() {
        delete_nodes(head_);
    }
};
```
**Sources**
1. http://cppjournal.blogspot.com/2010/11/lock-free-1.html
2. http://cppjournal.blogspot.com/2010/11/lock-free-2.html

### ABA Problem
Now, the `ABA` problem is an anomaly where Compare and Swap approach alone fails us.
Say, for example, that one activity reads some shared memory `(A)`, in preparation for updating it. Then, another activity temporarily modifies that shared memory `(B)` and then restores it `(A)`. Following that, once the first activity performs Compare and Swap, it will appear as if no change has been made, invalidating the integrity of the check.
While in many scenarios this doesn’t cause a problem, at times, `A` is not as equal to `A` as we might think.

Let’s think about a multithreaded scenario when Thread 1 and Thread 2 are operating on the same bank account.
When Thread 1 wants to withdraw some money, it reads the actual balance to use that value for comparing the amount in the CAS operation later. However, for some reason, Thread 1 is a bit slow — maybe it’s blocked.

In the meantime, Thread 2 performs two operations on the account using the same mechanism while Thread 1 is suspended. First, it changes the original value, which has already been read by Thread 1, but then, it changes it back to the original value.

Once Thread 1 resumes, it will appear as if nothing has changed, and CAS will succeed:

![](https://www.baeldung.com/wp-content/uploads/sites/4/2020/05/aba_problem-1-1024x499.png)

**Sources**
1. https://www.baeldung.com/cs/aba-concurrency

![](https://sun9-9.userapi.com/impg/08LVvGoL_V4aiPWkrt4VVAFP7CCNwWyTaJSzbA/o31IioI3T64.jpg?size=622x499&quality=96&sign=5dd253a7f56608a51f724597255c82cc&type=album)

## External and Internal Linkage
A translation unit refers to an implementation (.c/.cpp) file and all header (.h/.hpp) files it includes. If an object or function inside such a translation unit has internal linkage, then that specific symbol is only visible to the linker within that translation unit. If an object or function has external linkage, the linker can also see it when processing other translation units. The static keyword, when used in the global namespace, forces a symbol to have internal linkage. The extern keyword results in a symbol having external linkage.

The compiler defaults the linkage of symbols such that:

1. Non-const global variables have external linkage by default
2. Const global variables have internal linkage by default
3. Functions have external linkage by default

### Declaration vs Definition
Lets quickly discuss the difference between declaring a symbol and defining a symbol: A declaration tells the compiler about the existence of a certain symbol and makes it possible to refer to that symbol everywhere where the explicit memory address or required storage of that symbol is not required. A definition tells the compiler what the body of a function contains or how much memory it must allocate for a variable.

Situations where a declaration is not sufficient to the compiler are, for example, when a data member of a class is of reference or value (as in, neither reference nor pointer) type. At the same time, it is always allowed to have pointers to a declared (but not defined) type, because pointers require fixed memory capacity (e.g. 8 bytes on 64-bit systems) and do not depend on the type pointed to. When you dereference that pointer, the definition does become necessary. Also, for function declarations, all parameters (no matter whether taken by value, reference or pointer) and the return type need only be declared and not defined. Definitions of parameter and return value types only become necessary for the function definition.

#### Example
```cpp
// declarations
int f();

int f();

int f();

int f();

int f();

int f();

// definition
int f() {
    std::cout << "I'm f()";
}

int main() {
    f();
    return 0;
}
```
_Output - I'm f()_
```cpp
// declarations
int f();

int f();

int f();

int f();

int f();

int f();

// definitions
int f() {
    std::cout << "I'm f()";
}

int f() {
    std::cout << "I'm also f()";
}

int main() {
    f();
    return 0;
}
```
_Output - CE (due to [ODR](https://en.cppreference.com/w/cpp/language/definition))_
```cpp
class A;

class B {
private:
    A* a;
};
```
We don't care about the definition of class A, because pointers have fixed size

### Forward Declaration
In C++ there exists the concept of forward declaring a symbol. What we mean by this is that we declare the type and name of a symbol so that we can use it where its definition is not required. By doing so, we don’t have to include the full definition of a symbol (usually a header file) when it is not explicitly necessary. This way, we reduce dependency on the file containing the definition. The main advantage of this is that when the file containing the definition changes, the file where we forward declared that symbol does not need to be re-compiled (and therefore, also not all further files including it).
#### Example
```cpp
class A;

void f (A& a) {
    // some code
}
```
By forward declaring A, the only files requiring recompilation are a.hpp and f.cpp (assuming that’s where f is defined).

### External Linkage
#### Example 1
`header.hpp`
```cpp
int x = 5;
```
`main.cpp`
```cpp
extern int x;

int main() {
    std::cout << x;
    return 0;
}
```
#### Example 2
`header.hpp`
```cpp
void f() {
  std::cout << "I'm f()";
}
```
`first.cpp`
```cpp
#include <header.hpp>

/*other code*/

```
`second.cpp`
```cpp
#include <header.hpp>

/*other code*/

```
The linker found two definitions for the same symbol f. Because it had external linkage, f was visible to the linker when processing both first.cpp and second.cpp. Naturally, this violates the One-Definition-Rule, so this causes a linker error.
### Internal Linkage
`header.hpp`
```cpp
static int x = 10;
```
`first.hpp`
```cpp
void f1();
```
`second.hpp`
```cpp
void f2();
```
`first.cpp`
```cpp
#include <header.hpp>

void f1() {
  x = 11;
}
```
`second.cpp`
```cpp
#include <header.hpp>

void f2() {
  x = -11;
}
```
`main.cpp`
```cpp
#include <header.hpp>
#include <first.hpp>
#include <second.hpp>

int main() {
  f1();
  f2();
  std::cout << x;
  return 0;
}
```
_Output - 10_

**Sources:**
1. http://www.goldsborough.me/c/c++/linker/2016/03/30/19-34-25-internal_and_external_linkage_in_c++/

## Hunter
### Install
```sh
wget https://raw.githubusercontent.com/cpp-pm/gate/master/cmake/HunterGate.cmake -O cmake/HunterGate.cmake
```
## Sources
1. [A.A. Borodin](https://github.com/drewxa)'s lectures
2. [Google](https://www.google.ru/)
3. Video of some Indian from YouTube

Have you read to here? I am glad to welcome you to
![](https://sun9-49.userapi.com/impg/iGjsn_4WWv9tEkpYeZTCLdSMJv3z35T8w_QLIw/1laQp36zUJU.jpg?size=1125x624&quality=96&sign=c96c63aae3e186feafbba57f26ed2d86&type=album)
